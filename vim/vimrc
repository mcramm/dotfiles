call pathogen#infect()

set nocompatible
set t_Co=256
set background=dark
colorscheme solarized
set cursorline

set number
set ruler
syntax on

" Set encoding
set encoding=utf-8

" Whitespace stuff
set nowrap
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set autoindent
set smartindent
set list listchars=tab:\ \ ,trail:Â·

" Required to load rvm env in vim
set shell=/bin/sh

"syntax on
syntax enable
filetype plugin indent on

" Searching
set hlsearch
set incsearch
set ignorecase
set smartcase

" Tab completion
set wildmenu
set wildmode=longest,list

let mapleader = ","

" Command-T configuration
:let g:CommandTMaxHeight=20
:let g:CommandTAlwaysShowDotFiles=1
:let g:CommandTMaxFiles=20000
:map <C-T> :CommandT<CR>
:map <D-T> :CommandT<CR>

" Remember last location in file
if has("autocmd")
  au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal g'\"" | endif
endif

function s:setupWrapping()
  set wrap
  set wm=2
  set textwidth=72
endfunction

function s:setupMarkup()
  call s:setupWrapping()
  map <buffer> <Leader>p :Mm <CR>
endfunction

" make uses real tabs
au FileType make                                     set noexpandtab

" Thorfile, Rakefile, Vagrantfile and Gemfile are Ruby
au BufRead,BufNewFile {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru}    set ft=ruby

" md, markdown, and mk are markdown and define buffer-local preview
au BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn} call s:setupMarkup()

au BufRead,BufNewFile *.txt call s:setupWrapping()

" make python follow PEP8 ( http://www.python.org/dev/peps/pep-0008/ )
au FileType python  set tabstop=4 textwidth=79

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Directories for swp files
set backupdir=~/.vim/backup
set directory=~/.vim/backup

" Custom mappings
:map <F2> :set nowrap! <CR>
:map <F3> :set number! <CR>
:map <F4> :set paste! <CR>
 nmap gV '[v`]
" toggle background
call togglebg#map("<F5>")
map <Leader>gs :Gstatus <CR>
map <Leader>gc :Gcommit <CR>

" Status bar
set laststatus=2
set statusline=%<\ %n:%f\ %m%r%y%=%-35.(line:\ %l\ of\ %L,\ col:\ %c%V\ (%P)\ \ %{fugitive#statusline()}%)

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Running tests
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


function! RunTests(filename)
    " Write the file
    :w
    :silent !echo;echo;echo;echo;echo;echo;echo;echo;echo;echo

    " Run tests for the given filename
    if match(a:filename, '\.feature$') != -1
        exec ":!bundle exec cucumber " . a:filename
    else
        if filereadable("akelos/akelos")
          exec ":!script/test -u test/unit/" . substitute(a:filename, 'test\/unit\/', '', '')
        elseif filereadable("script/test")
            exec ":!script/test " . a:filename
        elseif filereadable("Gemfile")
            exec ":!bundle exec rspec --color " . a:filename
        else
            exec ":!rspec --color " . a:filename
        end
    end
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! RunTestFile(...)
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    if filereadable("akelos/akelos")
      call SetTestFile()
    else
      let in_test_file = match(expand("%"), '\(.feature\|_spec.rb\)$') != -1
      if in_test_file
          call SetTestFile()
      elseif !exists("t:grb_test_file")
          return
      end
    end
    call RunTests(t:grb_test_file . command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number)
endfunction

map <leader>t :call RunTestFile()<cr>
map <leader>T :call RunNearestTest()<cr>
map <leader>a :call RunTests('')<cr>
map <leader>c :w\|:!cucumber<cr>
map <leader>w :w\|:!cucumber --profile wip<cr>
